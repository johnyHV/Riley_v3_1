#include <Arduino.h>
#include <Wire.h>
#include "mux4067.h"
#include "premenne.h"
#include "drv8805_.h"
#include "tactical_IR_.h"
#include "sharp.h"
#include "ultrasonic.h"
#include "LM75.h"

//compass
#define Compas 0x1E
const int sampleTime = 10;

//akcelerometer
#define Acc 0x53
char POWER_CTL = 0x2D;        //Power Control Register
char DATA_FORMAT = 0x31;
char DATAX0 = 0x32;        //X-Axis Data 0
char DATAX1 = 0x33;        //X-Axis Data 1
char DATAY0 = 0x34;        //Y-Axis Data 0
char DATAY1 = 0x35;        //Y-Axis Data 1
char DATAZ0 = 0x36;        //Z-Axis Data 0
char DATAZ1 = 0x37;        //Z-Axis Data 1

// pin MUX
uint8_t mux_control_pin[4] = {36,37,38,39};
uint8_t mux_initial = 40;
uint8_t mux_output = 43;
mux4067 mux(mux_control_pin,mux_initial,mux_output);

// krokace
//step,sm,enable,dir,reset,home,faul,step_number,mux,mux_out
motor_control motor_l = {31,{26,27},22,28,0,50,2,0,true,43};
motor_control motor_r = {31,{26,27},23,29,3,52,5,0,true,43};
motor_control motor_f = {31,{26,27},24,30,6,52,8,0,true,43};
motor_control motor_b = {31,{26,27},25,30,9,52,11,0,true,43};
bool b_mod[4] = {false,false,false,false};
//bool kontrola = true;

// IR senzory
//mux,critical,komparator,analog
IR_proximity proximity = {false,{2,3},{41,42},{2,3}};
const uint8_t sharp_f = 4;
const uint8_t sharp_b = 5;

//ultrazvuk
ultrasonic uz_f = {35,34};
ultrasonic uz_b = {32,33};

//teplotne senzory
LM75 temp_u(0x48);		//72
LM75 temp_d(0x49);		//73

//kalibracne konstatny
uint8_t c_x_constant,c_y_constant,c_z_constant=0;
uint8_t a_constant[3]={0};

// funkcie
uint8_t kalibracia(uint8_t &,uint8_t &,uint8_t &);
int azimuth_cisty();
int azimuth_acc();
void initial_device(byte address, byte val,int DEVICE);
void read_data(byte address, int16_t (&data)[3],int DEVICE);
float RadiansToDegrees(float rads);

void setup() {
	Serial.begin(9600);
	Serial.println("+-------------------------+");
	Serial.println("| Start Boot");
  
    Serial.println("|");Serial.println("| Multiplexor");
	

	Serial.println("|");Serial.println("| Motor");
	//nastavenie modu kolies
	motor_initial(mux,&motor_l);					//inicializacia laveho motora
	motor_initial(mux,&motor_r);					//inicializacia praveho motora
	motor_initial(mux,&motor_f);
	motor_initial(mux,&motor_b);
	motor_enable(&motor_l,&motor_r,false,false);	//vypnutie pohonovych motorov
	motor_enable(&motor_f,&motor_b,false,false);	//vypnutie motorov pre hlavy
	motor_set_mod(&motor_l,0);

	Serial.println("|");Serial.println("| I2C");
	Wire.begin();									// zapnutie I2C
	
	Serial.println("|");Serial.println("| Compas");
	int16_t pamet[3]={0};
	initial_device(0x02, 0x00,Compas);
	read_data(0x03, pamet ,Compas);
	
	Serial.print("| X:");Serial.print(pamet[0]);
	Serial.print(" y:");Serial.print(pamet[1]);
	Serial.print(" z:");Serial.println(pamet[2]);
	Serial.print("| Azimuth mag: ");Serial.println(azimuth_cisty());
	

//	Serial.print(c_x_constant);
//	Serial.print(c_y_constant);
//	Serial.print(c_z_constant);
//	kalibracia(c_x_constant,c_y_constant,c_z_constant);
//	Serial.println(c_x_constant);
//	Serial.println(c_y_constant);
//	Serial.println(c_z_constant);
	 
	
	Serial.println("|");Serial.println("| Akcelerometer");
	initial_device(DATA_FORMAT, 0x01,Acc);
	initial_device(POWER_CTL, 0x08,Acc);
	read_data( DATAX0, pamet,Acc);
	Serial.print("| X:");Serial.print(pamet[0]);
	Serial.print(" y:");Serial.print(pamet[1]);
	Serial.print(" z:");Serial.println(pamet[2]);
	Serial.print("| Azimuth mag + acc: ");Serial.println(azimuth_acc());

	Serial.println("|");Serial.println("| Proximity");
	proximity_initial(&proximity,mux);					//inicializacia proximity
	Serial.print("| Critical: ");Serial.println(proximity_critical_status(&proximity));
	sharp_init();
	Serial.print("| Fron sharp: ");Serial.println(sharp_distance(sharp_f));
	
	Serial.println("|");Serial.println("| Ultrasonic");
	ultrasonic_initial(&uz_f);
	ultrasonic_initial(&uz_b);
	Serial.print("| Fron ultra sonic: ");
	Serial.println(ultrasonic_distance(&uz_f));
	//Serial.print("| Back ultra sonic: ");
	//Serial.println(ultrasonic_distance(&uz_b));
	
	Serial.println("|");Serial.println("| Tempeature");
	Serial.print("| Tempeature UP: ");
	Serial.print(temp_u.temp());Serial.println(" C");
	Serial.print("| Tempeature DOWN: ");
	Serial.print(temp_d.temp());Serial.println(" C");
	temp_u.shutdown(true);
	temp_d.shutdown(true);
	
	Serial.println("|");Serial.println("| Start");
	Serial.println("+-------------------------+");

}

void loop() {
/*
	if (kontrola)
	{
			// Compass
		int x, y, z;
		unsigned long time,times;
		int x_new,y_new,z_new,x_old,y_old,z_old;
		int16_t time_c=0;
		time=millis();
	
		while(time_c != 1)
		{
			times = millis() - time;
			if(times > sampleTime)
			{	
				// Inicializacia komunikacie s kompasom
				Wire.beginTransmission(Compas);
				Wire.write(byte(0x03));       // poslanie poziadavky pre X MSB register
				Wire.endTransmission();
				time=millis();	
				time_c++;	
				Wire.requestFrom(Compas, 6);    // ziadanie 6 bytes; 2 bytes pre os
				if(Wire.available() <=6) {      // pokial je 6 bytes k dispozicii
					x_new = Wire.read() << 8 | Wire.read();
					y_new = Wire.read() << 8 | Wire.read();
					z_new = Wire.read() << 8 | Wire.read();
				}
	
				if(time_c = 1)
				{
					x_old=x_new;
					y_old=y_new;
					z_old=z_new;
				}
			}
		}
		
		x= (x_old + x_new)/2*times;
		y= (y_old + y_new)/2*times;
		z= (z_old + z_new)/2*times;

		
		int azimut = int(atan((double)y/(double)x)*(360/PI));
		Serial.println(azimut);
    
		if (azimut > 0)
			motor_step(&motor_l,&motor_r,true,true);
		else if (azimut < 0)
			motor_step(&motor_l,&motor_r,false,false);
			else
				kontrola = false;
	}
	*/
	//if (!kontrola)
		motor_enable(&motor_l,&motor_r,b_mod[2],b_mod[3]);
		motor_step(&motor_l,&motor_r,b_mod[0],b_mod[1]);
		//motor_enable(&motor_f,&motor_b,b_mod[2],b_mod[3]);
		//motor_step(&motor_f,&motor_b,b_mod[0],b_mod[1]);
		//motor_enable(&motor_l,&motor_r,true,true);
	//delay(10);
	delayMicroseconds(1800);
	
	if (Serial.available() > 0) {
		int incomingByte = Serial.read();
		
		if ( incomingByte == 119) {		// w - dopredu
			b_mod[0]=true; b_mod[1]=false; b_mod[2]=true; b_mod[3]=true; }
		else if ( incomingByte == 97 ) {	// a - vlavo
			b_mod[0]=false; b_mod[1]=false; b_mod[2]=true; b_mod[3]=true; }
		else if ( incomingByte == 100 ) { // d- v pravo
			b_mod[0]=true; b_mod[1]=true; b_mod[2]=true; b_mod[3]=true; }
		else if ( incomingByte == 115 ) { // s - vzad
			b_mod[0]=false; b_mod[1]=true; b_mod[2]=true; b_mod[3]=true; }
		else if ( incomingByte == 101 ) { // e -  stop
			b_mod[0]=false; b_mod[1]=false; b_mod[2]=false; b_mod[3]=false; }
		else if ( incomingByte == 113 ) { // q - ziskanie dat z kompasu
			Serial.print("Azimuth cisty: "); Serial.println(azimuth_cisty());
			Serial.print("Azimuth acc: ");   Serial.println(azimuth_acc()); }
		else if ( incomingByte == 99 ) {	// c - ziskanie statusu kritickych bodov
			Serial.print("Critical: ");
			Serial.println(proximity_critical_status(&proximity)); }
		else if (( incomingByte >= 48 ) && ( incomingByte <= 57 )) { // z - vybratie IR senzora
			Serial.println(incomingByte-48);
			Serial.print("Vystup: ");
			Serial.println(proximity_d_status(&proximity,incomingByte-48,mux));	}
		else if ( incomingByte == 116 ) {	// t - ziskanie teplot z LM75
			temp_u.shutdown(false);temp_d.shutdown(false);
			Serial.print("Tempeature UP: "); 
			Serial.print(temp_u.temp());Serial.println(" C");
			Serial.print("Tempeature DOWN: ");
			Serial.print(temp_d.temp());Serial.println(" C"); 
			temp_u.shutdown(true);temp_d.shutdown(true);}
			
		
		Serial.print("I received: ");
		Serial.println(incomingByte);
	}
}


uint8_t kalibracia(uint8_t &v_c_x_constant,uint8_t &v_c_y_constant,uint8_t &v_c_z_constant) {
	int c_x_max,c_y_max,c_z_max,a_x_max,a_y_max,a_z_max=0;
	int c_x_min,c_y_min,c_z_min,a_x_min,a_y_min,a_z_min=255;
	
	//for (int i=0;i<8500;i++)
	for (int i=0;i<17000;i++)
	{
		motor_step(&motor_l,&motor_r,true,true);
		delayMicroseconds(1400);
		//Serial.println(i);
		//extremy kompasu
		Wire.beginTransmission(Compas);
		Wire.write(byte(0x03));       // poslanie poziadavky pre X MSB register
		Wire.endTransmission();
		Wire.requestFrom(Compas, 6);    // ziadanie 6 bytes; 2 bytes pre os
		if(Wire.available() <=6) {      // pokial je 6 bytes k dispozicii
			uint8_t x = Wire.read() << 8 | Wire.read();
			uint8_t y = Wire.read() << 8 | Wire.read();
			uint8_t z = Wire.read() << 8 | Wire.read();
			
			Serial.print("x: ");
			Serial.print(x);
			Serial.print(",y: ");
			Serial.print(y);
			Serial.print(",z: ");
			Serial.println(z);
			if (x > c_x_max)
				c_x_max = x;
			else if (x < c_x_min)
				c_x_min = x;
				
			if (y > c_y_max)
				c_y_max = y;
			else if (y < c_y_min)
				c_y_min = y;
				
			if (z > c_z_max)
				c_z_max = z;
			else if (z < c_z_min)
				c_z_min = z;
		}
	}
	
	Serial.println(c_x_max);
	Serial.println(c_x_min);
	v_c_x_constant = c_x_max - c_x_min;
	v_c_y_constant = c_y_max - c_y_min;
	v_c_z_constant = c_z_max - c_z_min;
}

int azimuth_cisty() {
	int16_t mag[3]={0};
	
	Wire.write(byte(0x03)); 
	read_data( 0x03, mag ,Compas);
	
	return int(RadiansToDegrees(atan2(mag[1],mag[0])));
}

int azimuth_acc() {
	float x_mag,z_mag,y_mag,x_acc,y_acc,z_acc=0;
	int16_t mag[3]={0};
	int16_t acc[3]={0};
	
	//vycitanie kompasa
	read_data( 0x03, mag,Compas); 
	
	//vycitanie acc
	read_data(DATAX0, acc,Acc);
	
	float rollRadians = atan2(acc[1],acc[2]);
	float pitchRadians = atan2(acc[0],acc[2]);
 
	// We cannot correct for tilt over 40 degrees with this algorthem, if the board is tilted as such, return 0.
	if(rollRadians > 0.78 || rollRadians < -0.78 || pitchRadians > 0.78 || pitchRadians < -0.78)
	{
		return 0;
	}
  
	// Some of these are used twice, so rather than computing them twice in the algorithem we precompute them before hand.
	float cosRoll = cos(rollRadians);
	float sinRoll = sin(rollRadians);  
	float cosPitch = cos(pitchRadians);
	float sinPitch = sin(pitchRadians);
  
	// The tilt compensation algorithem.
	float Xh = mag[0] * cosPitch + mag[2] * sinPitch;
	float Yh = mag[0] * sinRoll * sinPitch + mag[1] * cosRoll - mag[2] * sinRoll * cosPitch;
  
	float heading = atan2(Yh, Xh);
	return RadiansToDegrees(heading);
	
}

void initial_device(byte address, byte val,int DEVICE) {
	Wire.beginTransmission(DEVICE); 	// start transmission to device 
	Wire.write(address);             	// send register address
	Wire.write(val);                 	// send value to write
	Wire.endTransmission();         	// end transmission
}

void read_data(byte address, int16_t (&data)[3],int DEVICE) {
	Wire.beginTransmission(DEVICE);
	Wire.write(byte(address));       	// poslanie poziadavky pre X MSB register
	Wire.endTransmission();
	Wire.requestFrom(DEVICE, 6);    	// ziadanie 6 bytes; 2 bytes pre os
	
	if(Wire.available() <=6) {      	// pokial je 6 bytes k dispozicii
		data[0] = Wire.read() << 8 | Wire.read();
		data[1] = Wire.read() << 8 | Wire.read();
		data[2] = Wire.read() << 8 | Wire.read();
	}
}

float RadiansToDegrees(float rads)
{
  if(rads < 0)
    rads += 2*PI;
      
  if(rads > 2*PI)
    rads -= 2*PI;
   
  float heading = rads * 180/PI;
       
  return heading;
}

